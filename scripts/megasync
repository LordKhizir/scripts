#!/usr/bin/python3
# MegaSync
# Keep your folders in sync with Mega - ONE WAY ONLY
#
# It assumes Mega is your "source of truth".
# All syncs are then "down" syncs, it won't upload ANYTHING to Mega
# Works on top of mega-cmd
# Does a VERY conservative use of resources:
#   - loop through folders
#   - for each file, check if it needs to be updated
#   - download file by file
#   - Premise: Safe but slow if better than quick but inconsistent
#   - Don't trust dates, only file sizes. If they have different size, the file needs to be updated.

import os
import subprocess


class Content:
    def __init__(self, name, size, type):
        self.name = name
        self.size = size
        self.type = type

    def __lt__(self, other):
        return self.name < other.name


def safe_call(command):
    try:
        proc = subprocess.Popen(command, stdout=subprocess.PIPE)
        result = proc.stdout.read()
        return result
    except subprocess.CalledProcessError:
        print("--- ERROR ---")
        exit(1)


# Call source ls, get results, and preformat them for later use
def source_ls(path: str) -> [Content]:
    lines = safe_call([
        'mega-ls',
        '-l',
        path
    ])
    index: int = 0
    contents: [] = []
    for line in lines.splitlines():
        index += 1
        if index < 3:
            continue  # First two lines are just headers
        parts = line.decode('UTF-8').split(None, 5)
        content = Content(parts[5], parts[2], parts[0])
        contents.append(content)
    contents.sort()  # Sort before returning.. as source sort ordering can be different that destination
    return contents


def destination_ls(path: str) -> [Content]:
    lines = safe_call([
        'ls',
        '-lo',
        path
    ])
    index: int = 0
    contents: [] = []
    for line in lines.splitlines():
        index += 1
        if index < 2:
            continue  # First lines is a total
        parts = line.decode('UTF-8').split(None, 7)
        content = Content(parts[7], parts[3], parts[0])
        contents.append(content)
    contents.sort()  # Sort before returning.. as source sort ordering can be different that destination
    return contents


# Download file from source
def download(source_root: str, dest_root: str, path: str, filename: str):
    result = safe_call([
        'mega-get',
        source_root + "/" + path + "/" + filename,
        dest_root + "/" + path
    ])


# Remove file from destination
def destination_remove(dest_root: str, path: str, filename: str):
    _OLD_FILES = 'OLD_FILES'
    # check if directory exists or not yet
    old_path = dest_root + '/' + path
    new_path = dest_root + '/' + _OLD_FILES + '/' + path
    if not os.path.exists(new_path):
        os.makedirs(new_path)
    os.replace(old_path + '/' + filename, new_path + '/' + filename)
    print("Moved to", new_path)


# We have release info in secrets file
# import sys
# sys.path.append("../")
# from support import TootI_secrets

# TODO retrieve arguments
# TODO imnplement login if needed
# TODO apply
# export PATH=/Applications/MEGAcmd.app/Contents/MacOS:$PATH

# TODO get arguments from command line
sourceRoot: str = "Vault3D"
destRoot: str = "/Users/toni.navarro/NAS/Vault3D"
folder: str = "ARC Studios/Havoc Rises - vol 1 [KS] [INCOMPLETE]"

# Pending is implemented as a STACK - so append to end, pop the last element
pending: [] = [folder]
while len(pending) > 0:
    element: str = pending.pop()
    sourceContents = source_ls(sourceRoot + "/" + element)
    destinationContents = destination_ls(destRoot + "/" + element)

    # Loop thought BOTH list at the same time
    sourceIndex: int = 0
    destinationIndex: int = 0
    while (sourceIndex < len(sourceContents)) or (destinationIndex < len(destinationContents)):
        if sourceIndex < len(sourceContents):
            sourceItem = sourceContents[sourceIndex]
        else:
            sourceItem = ["zzzzz"]
        if destinationIndex < len(destinationContents):
            destinationItem = destinationContents[destinationIndex]
        else:
            destinationItem = ["zzzzz"]
        if sourceItem.name == destinationItem.name:
            # Element exists in both sides
            print(sourceItem.name)
            if sourceItem.size != destinationItem.size:
                print("⏬ Existing file, but different size found - updating")
                download(sourceRoot, destRoot, element, sourceItem.name)
            # Advance both indexes
            sourceIndex += 1
            destinationIndex += 1
        elif sourceItem.name < destinationItem.name:
            # Element exists only in Source
            print(sourceItem.name)
            print("⏬ New file")
            download(sourceRoot, destRoot, element, sourceItem.name)
            sourceIndex += 1
        else:
            # Element exists only in Destination
            print(destinationItem.name)
            print("❌ Deprecated file")
            destination_remove(destRoot, element, destinationItem.name)
            destinationIndex += 1

"""
for entry in os.scandir("."):
    if entry.is_file():
        name, extension = os.path.splitext(entry.name)
        if extension.lower() in (".rar", ".zip", ".7z"):
            print("\n========================================================\n")
            print("Unpacking", entry.name)
            newFile = workFolder + '/' + name + '.7z'
            os.mkdir(name)
            if extension.lower() == ".rar":
                # Rar5 is not supported by 7z
                safe_execute('unrar x "' + entry.name + '" "' + name + '"')
            else:
                safe_execute('7z x "' + entry.name + '" -o"' + name + '"')
            fix_double_folder(name)

            print("Packing")
            safe_execute('7za a -t7z -m0=lzma2 -mx=9 -mqs=on -mfb=64 -md=1024m -ms=on ' +
                         '-xr!.DS_Store -xr!Thumbs.db -xr!desktop.ini ' +
                         '"' + newFile + '" "' + name + '/"')
            # Remove temp folder for the file
            safe_execute('rm -r "' + name + '"')

            size_old = os.path.getsize(entry.name)
            size_new = os.path.getsize(newFile)
            print("Old size:", size_old, " New size:", size_new)
            print('Savings:', ((size_old - size_new) * 100) / size_old, '% -- ', size_old - size_new, 'bytes')

            # If the original file was already a 7z, check if new file is smaller than the first one
            # sometimes it happens, depending on compression method
            if extension.lower() == ".7z":

                if size_old < size_new:
                    print("Restoring original file, as it's smaller")
                    safe_execute('mv "' + entry.name + '" "' + newFile + '"')
                    size_new = size_old
                else:
                    os.remove(entry.path)
            else:
                os.remove(entry.path)

            sum_size_old += size_old
            sum_size_new += size_new
"""
